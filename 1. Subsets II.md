# Description

Given a list of numbers that may has duplicate numbers, return all possible subsets

 Notice

- Each element in a subset must be in non-descending order.
- The ordering between two subsets is free.
- The solution set must not contain duplicate subsets.

# Solution

- like subsets, but when meet an element equal to the element before it, just push it only on the newly added set
```
class Solution {
public:
    /*
     * @param nums: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    vector<vector<int>> subsetsWithDup(vector<int> &nums) {
        // write your code here
        sort(nums.begin(), nums.end());
        vector<vector<int>> ret;
        ret.push_back(vector<int>());
        int l, ol = 1;
        for (int i = 0; i < nums.size(); ++i) {
            l = 0;
            if (i != 0 && nums[i] == nums[i-1])
                l = ol;
            ol = ret.size();
            for (int j = l; j < ol; ++j) {
                auto t = ret[j];
                t.push_back(nums[i]);
                ret.push_back(t);
            }
        }
        return ret;
    }
};
```
